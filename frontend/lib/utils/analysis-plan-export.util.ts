/**
 * Analysis Plan Export Utility
 * Phase 10 Day 5.10 - Enterprise Grade
 *
 * Generates comprehensive analysis plans for operationalized research questions
 */

import type { OperationalizationResult } from '../types/questionnaire-import.types';

export class AnalysisPlanExportUtil {
  /**
   * Generate complete analysis plan as formatted text
   */
  static generateAnalysisPlan(result: OperationalizationResult): string {
    const sections: string[] = [];

    sections.push(this.generateHeader(result));
    sections.push(this.generateConstructsSummary(result));
    sections.push(this.generateMeasurementPlan(result));
    sections.push(this.generateDataCollectionPlan(result));
    sections.push(this.generateAnalysisStrategy(result));
    sections.push(this.generateReliabilityPlan(result));
    sections.push(this.generateValidityPlan(result));
    sections.push(this.generateRecommendations(result));

    return sections.join('\n\n');
  }

  /**
   * Generate header section
   */
  private static generateHeader(result: OperationalizationResult): string {
    return `================================================================================
RESEARCH ANALYSIS PLAN
Generated by VQMethod Platform
Date: ${new Date().toLocaleDateString()}
================================================================================

RESEARCH QUESTION:
${result.researchQuestion}

STUDY TYPE: ${this.getStudyTypeLabel(result)}
METHODOLOGY: ${result.methodology.approach}
RECOMMENDED SAMPLE SIZE: N ≥ ${result.statisticalPlan.primaryAnalysis.sampleSizeRecommendation}

================================================================================`;
  }

  /**
   * Generate constructs summary
   */
  private static generateConstructsSummary(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'IDENTIFIED CONSTRUCTS',
      '================================================================================',
    ];

    result.constructs.forEach((construct, index) => {
      lines.push(
        `\n${index + 1}. ${construct.name} (${this.getConstructTypeLabel(construct.type)})`
      );
      lines.push(`   Definition: ${construct.definition}`);
      lines.push(`   Confidence: ${(construct.confidence * 100).toFixed(1)}%`);
      if (construct.relatedConcepts.length > 0) {
        lines.push(
          `   Related Concepts: ${construct.relatedConcepts.join(', ')}`
        );
      }
    });

    return lines.join('\n');
  }

  /**
   * Generate measurement plan
   */
  private static generateMeasurementPlan(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'MEASUREMENT PLAN',
      '================================================================================',
    ];

    result.variables.forEach((variable, index) => {
      const items = result.measurementItems.filter(
        item => item.variableId === variable.id
      );
      const construct = result.constructs.find(
        c => c.id === variable.constructId
      );

      lines.push(`\n${index + 1}. ${variable.variableName}`);
      lines.push(`   Construct: ${construct?.name || 'Unknown'}`);
      lines.push(
        `   Operational Definition: ${variable.operationalDefinition}`
      );
      lines.push(`   Measurement Level: ${variable.measurementLevel}`);
      lines.push(`   Measurement Approach: ${variable.measurementApproach}`);
      lines.push(`   Number of Items: ${items.length}`);
      lines.push(
        `   Expected Reliability (α): ${variable.reliability.expectedAlpha.toFixed(2)}`
      );
      lines.push(
        `   Target Reliability (α): ≥ ${variable.reliability.targetAlpha.toFixed(2)}`
      );

      lines.push(`\n   Survey Items:`);
      items.forEach((item, itemIndex) => {
        lines.push(
          `   ${itemIndex + 1}. ${item.text}${item.reversed ? ' (REVERSED)' : ''}`
        );
        lines.push(`      Scale: ${item.scaleLabels.join(' | ')}`);
      });
    });

    return lines.join('\n');
  }

  /**
   * Generate data collection plan
   */
  private static generateDataCollectionPlan(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'DATA COLLECTION PLAN',
      '================================================================================',
      '',
      `Approach: ${result.methodology.approach}`,
      `Justification: ${result.methodology.justification}`,
      `Recommended Sample Size: N ≥ ${result.methodology.sampleSize}`,
      `Data Collection Method: ${result.methodology.dataCollection}`,
      '',
      'Survey Structure:',
      `- Total Items: ${result.measurementItems.length}`,
      `- Reverse-Coded Items: ${result.measurementItems.filter(i => i.reversed).length}`,
      `- Estimated Completion Time: ${Math.ceil(result.measurementItems.length * 0.5)} minutes`,
    ];

    return lines.join('\n');
  }

  /**
   * Generate analysis strategy
   */
  private static generateAnalysisStrategy(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'STATISTICAL ANALYSIS STRATEGY',
      '================================================================================',
      '',
      'PRIMARY ANALYSIS:',
      `Method: ${result.statisticalPlan.primaryAnalysis.method}`,
      `Description: ${result.statisticalPlan.primaryAnalysis.description}`,
      `Required Sample Size: N ≥ ${result.statisticalPlan.primaryAnalysis.sampleSizeRecommendation}`,
      '',
      'Statistical Assumptions:',
    ];

    result.statisticalPlan.primaryAnalysis.assumptions.forEach(
      (assumption, index) => {
        lines.push(`${index + 1}. ${assumption}`);
      }
    );

    if (result.statisticalPlan.secondaryAnalyses.length > 0) {
      lines.push('', 'SECONDARY ANALYSES:');
      result.statisticalPlan.secondaryAnalyses.forEach((analysis, index) => {
        lines.push(`\n${index + 1}. ${analysis.method}`);
        lines.push(`   Purpose: ${analysis.purpose}`);
        lines.push(`   When: ${analysis.when}`);
      });
    }

    return lines.join('\n');
  }

  /**
   * Generate reliability plan
   */
  private static generateReliabilityPlan(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'RELIABILITY ASSESSMENT PLAN',
      '================================================================================',
      '',
      'Reliability Checks:',
    ];

    result.statisticalPlan.reliabilityChecks.forEach((check, index) => {
      lines.push(`\n${index + 1}. ${check.construct}`);
      lines.push(`   Method: ${check.method}`);
      lines.push(`   Acceptable Threshold: α ≥ ${check.threshold.toFixed(2)}`);
    });

    lines.push('', 'Quality Metrics:');
    lines.push(
      `- Overall Expected Reliability: α = ${result.qualityMetrics.reliabilityExpectation.toFixed(2)}`
    );
    lines.push(
      `- Construct Coverage: ${(result.qualityMetrics.constructCoverage * 100).toFixed(1)}%`
    );

    return lines.join('\n');
  }

  /**
   * Generate validity plan
   */
  private static generateValidityPlan(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'VALIDITY ASSESSMENT PLAN',
      '================================================================================',
      '',
      'Validity Checks:',
    ];

    result.statisticalPlan.validityChecks.forEach((check, index) => {
      lines.push(`\n${index + 1}. ${check.type}`);
      lines.push(`   ${check.description}`);
    });

    lines.push('', 'Validity Indicators:');
    result.qualityMetrics.validityIndicators.forEach((indicator, index) => {
      lines.push(`${index + 1}. ${indicator}`);
    });

    return lines.join('\n');
  }

  /**
   * Generate recommendations
   */
  private static generateRecommendations(
    result: OperationalizationResult
  ): string {
    const lines: string[] = [
      'RECOMMENDATIONS',
      '================================================================================',
      '',
      'Pilot Testing:',
      result.recommendations.pilotTesting,
      '',
      'Validation Strategy:',
      result.recommendations.validationStrategy,
    ];

    if (result.recommendations.improvementSuggestions.length > 0) {
      lines.push('', 'Improvement Suggestions:');
      result.recommendations.improvementSuggestions.forEach(
        (suggestion, index) => {
          lines.push(`${index + 1}. ${suggestion}`);
        }
      );
    }

    lines.push(
      '',
      '================================================================================'
    );
    lines.push('END OF ANALYSIS PLAN');
    lines.push(
      '================================================================================'
    );

    return lines.join('\n');
  }

  /**
   * Helper methods
   */
  private static getStudyTypeLabel(result: OperationalizationResult): string {
    // Study type not directly in result, infer from methodology or use generic
    return (
      result.methodology.approach.charAt(0).toUpperCase() +
      result.methodology.approach.slice(1) +
      ' Study'
    );
  }

  private static getConstructTypeLabel(type: string): string {
    return type
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Export as JSON
   */
  static generateJSON(result: OperationalizationResult): string {
    return JSON.stringify(result, null, 2);
  }

  /**
   * Download analysis plan as text file
   */
  static downloadTextPlan(
    result: OperationalizationResult,
    filename?: string
  ): void {
    const plan = this.generateAnalysisPlan(result);
    const blob = new Blob([plan], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `analysis_plan_${Date.now()}.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Download analysis plan as JSON
   */
  static downloadJSONPlan(
    result: OperationalizationResult,
    filename?: string
  ): void {
    const json = this.generateJSON(result);
    const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `analysis_plan_${Date.now()}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Copy to clipboard
   */
  static async copyToClipboard(
    result: OperationalizationResult
  ): Promise<void> {
    const plan = this.generateAnalysisPlan(result);
    await navigator.clipboard.writeText(plan);
  }
}
