/**
 * SPSS Syntax Export Utility
 * Phase 10 Day 5.10 - Enterprise Grade
 *
 * Generates SPSS syntax for research question operationalization results
 * Based on: IBM SPSS Statistics Syntax Reference Guide
 */

import type {
  OperationalizationResult,
  SurveyMeasurementItem,
} from '../types/questionnaire-import.types';

export class SPSSExportUtil {
  /**
   * Generate complete SPSS syntax for operationalization result
   */
  static generateSyntax(result: OperationalizationResult): string {
    const sections: string[] = [];

    // Header
    sections.push(this.generateHeader(result));

    // Variable definitions
    sections.push(this.generateVariableDefinitions(result));

    // Value labels
    sections.push(this.generateValueLabels(result));

    // Reliability analysis
    sections.push(this.generateReliabilityAnalysis(result));

    // Primary analysis
    sections.push(this.generatePrimaryAnalysis(result));

    // Descriptive statistics
    sections.push(this.generateDescriptives(result));

    return sections.join('\n\n');
  }

  /**
   * Generate header with metadata
   */
  private static generateHeader(result: OperationalizationResult): string {
    return `* ================================================================
* SPSS Syntax for Research Question Operationalization
* Generated by VQMethod Platform
* Date: ${new Date().toISOString().split('T')[0]}
* ================================================================
* Research Question: ${result.researchQuestion}
* Study Type: ${this.getStudyTypeLabel(result)}
* Total Constructs: ${result.constructs.length}
* Total Variables: ${result.variables.length}
* Total Survey Items: ${result.measurementItems.length}
* ================================================================.`;
  }

  /**
   * Generate variable definitions
   */
  private static generateVariableDefinitions(
    result: OperationalizationResult
  ): string {
    const lines: string[] = ['* Variable Definitions', 'VARIABLE LABELS'];

    result.measurementItems.forEach(item => {
      const varName = this.getVariableName(item);
      const label = item.text.substring(0, 255); // SPSS label limit
      lines.push(`  ${varName} "${this.escapeSPSS(label)}"`);
    });

    lines.push('.');
    return lines.join('\n');
  }

  /**
   * Generate value labels for scale items
   */
  private static generateValueLabels(result: OperationalizationResult): string {
    const lines: string[] = ['* Value Labels'];

    // Group items by scale type
    const scaleGroups = new Map<string, SurveyMeasurementItem[]>();
    result.measurementItems.forEach(item => {
      const key = JSON.stringify(item.scaleLabels);
      if (!scaleGroups.has(key)) {
        scaleGroups.set(key, []);
      }
      scaleGroups.get(key)!.push(item);
    });

    scaleGroups.forEach((items, key) => {
      const labels = JSON.parse(key) as string[];
      const varNames = items.map(item => this.getVariableName(item)).join(' ');

      lines.push(`VALUE LABELS ${varNames}`);
      labels.forEach((label, index) => {
        lines.push(`  ${index + 1} "${this.escapeSPSS(label)}"`);
      });
      lines.push('.');
    });

    return lines.join('\n');
  }

  /**
   * Generate reliability analysis syntax
   */
  private static generateReliabilityAnalysis(
    result: OperationalizationResult
  ): string {
    const lines: string[] = ["* Reliability Analysis (Cronbach's Alpha)"];

    result.variables.forEach(variable => {
      const items = result.measurementItems.filter(
        item => item.variableId === variable.id
      );

      if (items.length > 0) {
        const varNames = items
          .map(item => this.getVariableName(item))
          .join(' ');

        lines.push(`\n* Reliability for ${variable.variableName}`);
        lines.push(`RELIABILITY`);
        lines.push(`  /VARIABLES=${varNames}`);
        lines.push(`  /SCALE('${variable.variableName}') ALL`);
        lines.push(`  /MODEL=ALPHA`);
        lines.push(`  /STATISTICS=DESCRIPTIVE SCALE CORR`);
        lines.push(`  /SUMMARY=TOTAL.`);
      }
    });

    return lines.join('\n');
  }

  /**
   * Generate primary analysis syntax
   */
  private static generatePrimaryAnalysis(
    result: OperationalizationResult
  ): string {
    const method = result.statisticalPlan.primaryAnalysis.method;
    const lines: string[] = [`* Primary Analysis: ${method}`];

    if (method.includes('Regression')) {
      lines.push(this.generateRegressionSyntax(result));
    } else if (method.includes('Factor Analysis')) {
      lines.push(this.generateFactorAnalysisSyntax(result));
    } else if (method.includes('Correlation')) {
      lines.push(this.generateCorrelationSyntax(result));
    } else if (method.includes('t-test') || method.includes('ANOVA')) {
      lines.push(this.generateANOVASyntax(result));
    }

    return lines.join('\n');
  }

  /**
   * Generate regression syntax
   */
  private static generateRegressionSyntax(
    result: OperationalizationResult
  ): string {
    const dvVars = result.constructs.filter(
      c => c.type === 'dependent_variable'
    );
    const ivVars = result.constructs.filter(
      c => c.type === 'independent_variable'
    );

    if (dvVars.length === 0 || ivVars.length === 0) {
      return '* Note: Regression analysis requires both DV and IV constructs.';
    }

    const dv = dvVars[0]!; // Safe because we checked length above
    const dvItems = result.measurementItems.filter(
      item => item.constructId === dv.id
    );
    const ivItems = result.measurementItems.filter(item =>
      ivVars.some(iv => iv.id === item.constructId)
    );

    const dvVarNames = dvItems
      .map(item => this.getVariableName(item))
      .join(' + ');
    const ivVarNames = ivItems
      .map(item => this.getVariableName(item))
      .join(' ');

    return `REGRESSION
  /MISSING LISTWISE
  /STATISTICS COEFF OUTS R ANOVA COLLIN TOL
  /CRITERIA=PIN(.05) POUT(.10)
  /NOORIGIN
  /DEPENDENT (${dvVarNames}) / ${dvItems.length}
  /METHOD=ENTER ${ivVarNames}
  /SCATTERPLOT=(*ZRESID ,*ZPRED)
  /RESIDUALS HISTOGRAM(ZRESID) NORMPROB(ZRESID).`;
  }

  /**
   * Generate factor analysis syntax
   */
  private static generateFactorAnalysisSyntax(
    result: OperationalizationResult
  ): string {
    const allVarNames = result.measurementItems
      .map(item => this.getVariableName(item))
      .join(' ');

    return `FACTOR
  /VARIABLES ${allVarNames}
  /MISSING LISTWISE
  /ANALYSIS ${allVarNames}
  /PRINT UNIVARIATE INITIAL CORRELATION SIG DET KMO EXTRACTION ROTATION
  /FORMAT SORT BLANK(.30)
  /PLOT EIGEN ROTATION
  /CRITERIA MINEIGEN(1) ITERATE(25)
  /EXTRACTION PC
  /CRITERIA ITERATE(25) DELTA(0)
  /ROTATION VARIMAX
  /METHOD=CORRELATION.`;
  }

  /**
   * Generate correlation syntax
   */
  private static generateCorrelationSyntax(
    result: OperationalizationResult
  ): string {
    const allVarNames = result.measurementItems
      .map(item => this.getVariableName(item))
      .join(' ');

    return `CORRELATIONS
  /VARIABLES=${allVarNames}
  /PRINT=TWOTAIL NOSIG
  /MISSING=PAIRWISE.`;
  }

  /**
   * Generate ANOVA syntax
   */
  private static generateANOVASyntax(result: OperationalizationResult): string {
    const dvVars = result.constructs.filter(
      c => c.type === 'dependent_variable'
    );
    const ivVars = result.constructs.filter(
      c => c.type === 'independent_variable'
    );

    if (dvVars.length === 0 || ivVars.length === 0) {
      return '* Note: ANOVA requires both DV and IV constructs.';
    }

    const dv = dvVars[0]!; // Safe because we checked length above
    const iv = ivVars[0]!; // Safe because we checked length above
    const dvItems = result.measurementItems.filter(
      item => item.constructId === dv.id
    );
    const ivItems = result.measurementItems.filter(
      item => item.constructId === iv.id
    );

    if (ivItems.length === 0) {
      return '* Note: No measurement items found for IV construct.';
    }

    return `ONEWAY ${dvItems.map(i => this.getVariableName(i)).join(' ')} BY ${this.getVariableName(ivItems[0]!)}
  /STATISTICS DESCRIPTIVES HOMOGENEITY BROWNFORSYTHE WELCH
  /MISSING ANALYSIS
  /POSTHOC=TUKEY SCHEFFE BONFERRONI ALPHA(0.05).`;
  }

  /**
   * Generate descriptive statistics
   */
  private static generateDescriptives(
    result: OperationalizationResult
  ): string {
    const allVarNames = result.measurementItems
      .map(item => this.getVariableName(item))
      .join(' ');

    return `* Descriptive Statistics
DESCRIPTIVES VARIABLES=${allVarNames}
  /STATISTICS=MEAN STDDEV MIN MAX SKEWNESS KURTOSIS.`;
  }

  /**
   * Get SPSS-compatible variable name from item
   */
  private static getVariableName(item: SurveyMeasurementItem): string {
    // SPSS variable names: max 64 chars, alphanumeric + underscore, must start with letter
    const safe = item.id.replace(/[^a-zA-Z0-9_]/g, '_').substring(0, 64);

    // Ensure starts with letter
    return safe.match(/^[a-zA-Z]/) ? safe : `V${safe}`;
  }

  /**
   * Escape special characters for SPSS strings
   */
  private static escapeSPSS(text: string): string {
    return text
      .replace(/"/g, '""') // Double quotes
      .replace(/\n/g, ' ') // Remove newlines
      .replace(/\t/g, ' '); // Remove tabs
  }

  /**
   * Get study type label
   */
  private static getStudyTypeLabel(result: OperationalizationResult): string {
    return result.methodology?.approach || 'Not specified';
  }

  /**
   * Export as downloadable file
   */
  static downloadSyntax(
    result: OperationalizationResult,
    filename?: string
  ): void {
    const syntax = this.generateSyntax(result);
    const blob = new Blob([syntax], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || `spss_syntax_${Date.now()}.sps`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}
